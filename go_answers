package main

import (
	"log"
	"net/http"
	"sync"

	"github.com/gin-gonic/gin"
	"golang.org/x/time/rate"
)

type Message struct {
	Status string `json:"status"`
	Body   string `json:"body"`
}

type RateLimiter struct {
	ips map[string]*rate.Limiter
	mu  *sync.RWMutex
	r   rate.Limit
	b   int
}

func endpointHandler(c *gin.Context) {
	c.Header("Content-Type", "application/json")
	c.JSON(http.StatusOK, Message{
		Status: "Successful",
		Body:   "This is the endpoint for rate limiting",
	})
}

func main() {
	router := gin.Default()

	limiter := &RateLimiter{
		ips: make(map[string]*rate.Limiter),
		mu:  &sync.RWMutex{},
		r:   rate.Limit(1),
		b:   5,
	}

	router.POST("/api/endpoint", rateLimiter(limiter), endpointHandler)

	err := router.Run(":8080")
	if err != nil {
		log.Println("There was an error listening to port: 8080", err)
	}
}

func (rl *RateLimiter) CreateLimiter(ip string) *rate.Limiter {
	rl.mu.Lock()
	defer rl.mu.Unlock()

	limiter, exists := rl.ips[ip]

	if !exists {
		limiter = rate.NewLimiter(rl.r, rl.b)
		rl.ips[ip] = limiter
	}

	return limiter
}

func rateLimiter(rl *RateLimiter) gin.HandlerFunc {
	return func(c *gin.Context) {
		limiter := rl.CreateLimiter(c.ClientIP())
		if !limiter.Allow() {
			c.JSON(http.StatusTooManyRequests, gin.H{"error": "Requests exceeded"})
			c.Abort()
			return
		}

		c.Next()
	}
}
